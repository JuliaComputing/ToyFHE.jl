<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Cryptographic Schemes for FHE · ToyFHE.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link href="../../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ToyFHE.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../../">ToyFHE.jl</a></li><li><span class="toctext">Manual</span><ul><li><span class="toctext">Background</span><ul><li><a class="toctext" href="../">Cryptography background</a></li><li><a class="toctext" href="../rlwe/">Ring LWE and ℛq</a></li><li class="current"><a class="toctext" href>Cryptographic Schemes for FHE</a><ul class="internal"><li><a class="toctext" href="#FHE-generally-1">FHE generally</a></li><li><a class="toctext" href="#FHE-using-RLWE-1">FHE using RLWE</a></li></ul></li></ul></li><li><a class="toctext" href="../../encoding/">Ciphertext Encodings</a></li><li><a class="toctext" href="../../ckks/">The CKKS encryption scheme</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li>Background</li><li><a href>Cryptographic Schemes for FHE</a></li></ul><a class="edit-page" href="https://github.com/JuliaComputing/ToyFHE.jl/blob/master/docs/src/man/background/fhe.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Cryptographic Schemes for FHE</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Cryptographic-Schemes-for-FHE-1" href="#Cryptographic-Schemes-for-FHE-1">Cryptographic Schemes for FHE</a></h1><h2><a class="nav-anchor" id="FHE-generally-1" href="#FHE-generally-1">FHE generally</a></h2><p>A general (public-key) FHE scheme provides the following functions:</p><ul><li><code>(pub, priv) = keygen(...)</code> - Generates public and private keys</li><li><code>cipher = encrypt(pub, plain)</code> - Encrypts <code>x</code> using the public key <code>pub</code></li><li><code>plain = decrypt(priv, cipher)</code> - Decrypts the ciphertext using private key <code>priv</code></li><li><code>cipher_new = eval(f, ciphers...)</code> - Compute the function <code>f</code> on the encrypted values</li></ul><p>One particular important distinction between different FHE schemes is what functions <code>f</code> are allowed to be homomorphically. In particular, in order to be considered a <strong>somewhat</strong> or <strong>fully</strong> homomorphic encryption scheme (abbreviated SHE and FHE respectively), <code>f</code> needs to range over at least two different values that together allow some sort of universality (e.g. <code>+</code> and <code>*</code> on booleans is sufficient). The difference between SHE and FHE schemes is that SHE schemes may have a limit on the number of times that <code>eval</code> may be called, while FHE schemes are defined not to have such a limit. It is possible to turn many SHE schemes into FHE schemes using <a href="man/background/@ref"><code>bootstrapping</code></a></p><h2><a class="nav-anchor" id="FHE-using-RLWE-1" href="#FHE-using-RLWE-1">FHE using RLWE</a></h2><p>Since we are in the RLWE setting, the basic primitives we have available are polynomial multiplication (mod <code>q</code> and some cyclotomic) and polynomial addition or equivalently negacyclic convolution and addition for length <code>n</code> arrays. All three supported schemes <code>BGV</code>, <code>BFV</code> and <code>CKKS</code> allow evaluating negacyclic convolution and addition on encrypted length <code>n</code> arrays, though they differ in precisely how they embed their plaintext space into each polynomial. Broadly speaking BGV encodes the plaintext into the (masked) lower bits of the ciphertext, BFV encodes bits into the upper bits of the ciphertext and CKKS is, well complicated, but somewhat similar to BFV. Nevertheless, they do share a lot in common, so let&#39;s go over those parts and then revisit.</p><h3><a class="nav-anchor" id="Key-generation-for-RLWE-FHE-schemes-1" href="#Key-generation-for-RLWE-FHE-schemes-1">Key generation for RLWE FHE schemes</a></h3><p>The key structure is the same among all three schemes:</p><pre><code class="language-none">const ℛE = RingElement{ℛ}

struct PrivKey
    s::ℛE
end

struct PubKey
    mask::ℛE
    masked::ℛE
end</code></pre><p>We now define three probability distributions <span>$\mathscr{U}$</span> the uniform distribution over <span>$\mathscr{R}E$</span>, <span>$\mathscr{G}$</span> whose probability has discrete support near <code>0</code> and &quot;small&quot; standard deviation (common choices are discrete gaussian distributions with standard deviation <span>$\frac{8}{\sqrt{2\pi}}$</span>$ or the uniform distribution on <span>$\{-1, 0, 1\}$</span>), as well as a noise distribution <span>$\mathscr{N}$</span> that is scheme specific and may or may not be the same as <span>$\mathscr{G}$</span>.</p><p>We then compute</p><pre><code class="language-julia">s = rand(𝒢)
mask = rand(𝒰)
masked = -(mask * s + rand(𝒩))</code></pre><p>Note that that the problem of computing the private key <code>s</code> from the public key <code>(mask, masked)</code> is precisely the ring learning with error problem (i.e. the added noise makes computing <code>s</code> from <code>masked</code> hard, even if we do know the <code>mask</code>).</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>We use the opposite sign for <code>masked</code> from what is found in the literature on the BGV scheme. The reason for this deviation is to unify the presentation for all three schemes (The papers on BFV and CKKS generally follow the same sign convention as were are using here).</p></div></div><h3><a class="nav-anchor" id="Encryption-in-RLWE-FHE-1" href="#Encryption-in-RLWE-FHE-1">Encryption in RLWE FHE</a></h3><p>A fresh cipher text consits of two ring elements <code>c₀</code> and <code>c₁</code> computed as follows:</p><pre><code class="language-julia">u = rand(𝒢)
c₀ = u * masked + rand(𝒩) + π⁻¹(plain)
c₁ = u * mask + rand(𝒩)</code></pre><p>where <code>γ</code> is a scheme specific embedding function that maps the plaintext space into the cipher text space.</p><h3><a class="nav-anchor" id="Homomorphic-addition-1" href="#Homomorphic-addition-1">Homomorphic addition</a></h3><p>Homomorphic addition is simple. For two ciphertext <code>(c₀¹, c₁¹)</code> and <code>(c₀², c₁²)</code>, we simply add the ciphertexts elementwise and compute:</p><pre><code class="language-julia">c₀′ = c₀¹ + c₀²
c₁′ = c₁¹ + c₁²</code></pre><h3><a class="nav-anchor" id="Homomorphic-multiplication-1" href="#Homomorphic-multiplication-1">Homomorphic multiplication</a></h3><p>Homomorphic multiplication is generally similar between the schemes but differs in the details. This presentation most closely matches BGV. For two ciphertext <code>(c₀, c₁)</code> and <code>(d₀, d₁)</code>, we compute</p><pre><code class="language-julia">c₀′ = c₀ * d₀
c₁′ = (c₀ * d₁) + (d₀ * c₁)
c₂′ = c₁ * d₁</code></pre><p>Note that the number of elements in the ciphertext increases. As a result, we generally need to perform <em>relinerization</em> which is described below to get the number of elements of the ciphertext back down to 2. However, it is possible to decrypt ciphertexts with arbitrarily many elements. In general the number of elements in the ciphertexts is the sum of the number of elements in the input ciphertexts minus 1. Whether or not to do relinerization depends on the tradeoff between the cost of relinerization and the cost of performing multiplications with large numbers of ciphertext elements. The general formula for multiplying two ciphertexts is:</p><div>\[c_k\prime = \sum_{i+j == k} c_i * d_k\]</div><h3><a class="nav-anchor" id="Decryption-1" href="#Decryption-1">Decryption</a></h3><p>For a ciphertext <code>c = (c₀, ..., cⱼ)</code> the decryption formula is:</p><pre><code class="language-julia">plain = π(sum(cᵢ * s^i for (i,cᵢ) in enumerate(c)))</code></pre><p>where <code>π</code> is once again the scheme specific embedding we are familiar with from the encryption step. Why does this work? Well, lets take it one step at a time. Suppose we have a fresh encryption <code>(c₀, c₁)</code>. Then we have:</p><pre><code class="language-none">c₀ = u * masked + rand(𝒩) + π⁻¹(plain) = - u * mask * s - s * rand(𝒩) + π⁻¹(plain)
s * c₁ = u * mask * s + s * rand(𝒩)</code></pre><p>and thus</p><pre><code class="language-none">c₀ + c₁ = - s * rand(𝒩) + s * rand(𝒩) + π⁻¹(plain)</code></pre><p>We note that the two noise terms do not cancel, because they are independent draws (they do however cancel in expectation of course). Nevertheless, it is evident that one could choose <code>π</code> and <code>𝒩</code> appropriately such that <code>π</code> projects out the noise terms (recall that <code>s</code> was chosen to have small coefficients). In particular note that we have no term proportional to <code>mask</code>, which was sampled from the uniform distribution.</p><p>Repeating this exercise for the ciphertext after multiplication we obtain:</p><pre><code class="language-none">c₀′ = (u * masked + e₁ + π⁻¹(m₁)) * (v * masked + e₂ + π⁻¹(m₂))
    = u * v * masked ^ 2 +
      masked * (u * e₂ + v * e₁ + u * π⁻¹(m₂) + v * π⁻¹(m₁)) +
      e₁ * e₂ +
      π⁻¹(m₂)π⁻¹(m₂)
    =  u * v * mask^2 * s^2 + u * v * e^2
     - mask * s * (u * e₂ + v * e₁ + u * π⁻¹(m₂) + v * π⁻¹(m₁))
     + e * (u * e₂ + v * e₁ + u * π⁻¹(m₂) + v * π⁻¹(m₁))
     + e₁ * e₂
     + π⁻¹(m₂)π⁻¹(m₂)
s * c₁′ = s * (u * masked + e₁ + π⁻¹(m₁)) * v * mask +
          s * (u * masked + e₁ + π⁻¹(m₁)) * f₂ +
          s * (v * masked + e₂ + π⁻¹(m₂)) * u * mask +
          s * (v * masked + e₂ + π⁻¹(m₂)) * f₁
        = 2 s * u * v * masked * mask
        + mask * s * (u * e₂ + v * e₁ + u * π⁻¹(m₂) + v * π⁻¹(m₁))
        + s * (u * masked + e₁ + π⁻¹(m₁)) * f₂
        + s * (v * masked + e₂ + π⁻¹(m₂)) * f₁
        = - 2 * u * v * s^2 * mask^2
          + mask * s * (u * e₂ + v * e₁ + u * π⁻¹(m₂) + v * π⁻¹(m₁))
          - s^2 * u * mask * f₂
          - s^2 * u * mask * f₁
          + s * (u * e + e₁ + π⁻¹(m₁)) * f₂
          + s * (v * e + e₂ + π⁻¹(m₂)) * f₁
          + 2 * u * v * s * e
s^2 * c₂′ = (u * mask + f₁) * (v * mask + f₂)
          = u * mask * mask^2 * s^2 +
            s^2 * u * mask * f₂ +
            s^2 * v * mask * f₁ +
            s^2 * f₁ * f₂</code></pre><p>Summing these up, we get:</p><pre><code class="language-none">c₀′ + s * c₁′ + s^2 * c₂′ =
    π⁻¹(m₁)π⁻¹(m₂) +
    + e * (u * e₂ + v * e₁ + u * π⁻¹(m₂) + v * π⁻¹(m₁))
    + e₁ * e₂
    + s * (u * e + e₁ + π⁻¹(m₁)) * f₂
    + s * (v * e + e₂ + π⁻¹(m₂)) * f₁
    + 2 * u * v * s * e
    + s^2 * f₁ * f₂</code></pre><p>where <code>e₁, e₂, e, f₁, f₂</code> are the various values samples from <code>𝒩</code>. Clearly this decryption is more complicated. All the various noise terms are &quot;small&quot;, but we&#39;re multiplying a lot of them (and some by the embedded message), so the noise is certainly significant. However, the important thing to notice is that we have canceled all terms proportional to <code>mask</code>.</p><h3><a class="nav-anchor" id="Keyswitching-/-Modulus-Switching-1" href="#Keyswitching-/-Modulus-Switching-1">Keyswitching / Modulus Switching</a></h3><p><em>TODO</em></p><h3><a class="nav-anchor" id="BGV-1" href="#BGV-1">BGV</a></h3><p>We now turn to the three schemes themselves in order to specify the various operations we had left open above. For, BGV, we have:</p><pre><code class="language-none">𝒩 = p * 𝒢
π⁻¹(plain) = plain
π(c) = mod(c, p)</code></pre><p>It is easy to see that this works. In our expression above, ever value sampled from <code>𝒩</code> is proportional to <code>p</code> and thus our decryption will be equal to <span>$m₁ * m₂ + p * noise \equiv m₁ * m₂ (mod p)$</span> (as long as the total magnitude of <span>$p*noise$</span> is less than the ciphertext modulus <span>$q$</span>). We have thus constructed a scheme that can homomorphically evaluate operations in <code>ℤ/pℤ</code>. Recall from the introduction that we said BGV embeds the plaintext in the &quot;low order bits&quot; of the ciphertext. Perhaps a more precise statement would be that in BGV the plaintext is the (masked) last digit of the ciphertext in base <code>p</code>.</p><h3><a class="nav-anchor" id="BFV-1" href="#BFV-1">BFV</a></h3><p>BFV is essentially the opposite of BGV. We set:</p><pre><code class="language-none">𝒩 = 𝒢
π⁻¹(plain) = q/p * plain
π(c) = div(c, q/p, RoundToNearest)</code></pre><p>Because of this encoding we make one additional modification to the scheme. After every multiplication we divide by <code>Δ = q/p</code> (multiply by <code>p/q</code>) to rescale the plaintext to be once again be proportional to <code>Δ</code>. In order to do this, we amend the multiplication procedure as follows: Before performing the multiplication, we switch the coefficients to some larger modulus <code>q*t</code> where <code>t</code> is of same magnitude as (in number of bits) but slightly larger <code>q</code> than q. As a result, we know that <code>(Δ * m₁) * (Δ * m₂) &lt; Δ^2 m₁ m₂ &lt; q^2 &lt; q * t</code> and thus no modular wraparound occurs (which would lose the top bits of our plaintext).</p><p>Of course we could instead go all the way to ℤ. However, using <code>q*s</code> lets us continue using the fast NTT-based arithmetic to the multiplication.</p><h3><a class="nav-anchor" id="CKKS-1" href="#CKKS-1">CKKS</a></h3><p>CKKS is special among the three schemes we support in that it is not exact, i.e. we only ensure that the decrypted value approximately correct (for values of approximately that depend on the parameters of the scheme). As such, we use the perhaps paradoxically simple setup:</p><pre><code class="language-none">𝒩 = 𝒢
π⁻¹(plain) = plain
π(c) = c</code></pre><p>We thus see that even for fresh encryptions, the low order digits lose precision. Note that we do often still perform a BFV-like rescaling operation during multiplication in CKKS as we tend to think of the plaintext as some fixed point integer. Because the details are tricky and require additional functionality we have not yet discussed, working with CKKS will be explained in its own manual section later.</p><footer><hr/><a class="previous" href="../rlwe/"><span class="direction">Previous</span><span class="title">Ring LWE and ℛq</span></a><a class="next" href="../../encoding/"><span class="direction">Next</span><span class="title">Ciphertext Encodings</span></a></footer></article></body></html>
