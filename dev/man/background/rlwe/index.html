<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ring LWE and ‚Ñõq ¬∑ ToyFHE.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link href="../../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ToyFHE.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../../">ToyFHE.jl</a></li><li><span class="toctext">Manual</span><ul><li><span class="toctext">Background</span><ul><li><a class="toctext" href="../">Cryptography background</a></li><li class="current"><a class="toctext" href>Ring LWE and ‚Ñõq</a><ul class="internal"><li><a class="toctext" href="#The-ring-of-m-th-cyclotomic-integers-mod-q-1">The ring of m-th cyclotomic integers mod q</a></li><li><a class="toctext" href="#Power-of-two-cyclotomic-rings-1">Power of two cyclotomic rings</a></li></ul></li><li><a class="toctext" href="../fhe/">Cryptographic Schemes for FHE</a></li></ul></li><li><a class="toctext" href="../../encoding/">Ciphertext Encodings</a></li><li><a class="toctext" href="../../ckks/">The CKKS encryption scheme</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li>Background</li><li><a href>Ring LWE and ‚Ñõq</a></li></ul><a class="edit-page" href="https://github.com/JuliaComputing/ToyFHE.jl/blob/master/docs/src/man/background/rlwe.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Ring LWE and ‚Ñõq</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Ring-LWE-and-‚Ñõq-1" href="#Ring-LWE-and-‚Ñõq-1">Ring LWE and ‚Ñõq</a></h1><h2><a class="nav-anchor" id="The-ring-of-m-th-cyclotomic-integers-mod-q-1" href="#The-ring-of-m-th-cyclotomic-integers-mod-q-1">The ring of m-th cyclotomic integers mod q</a></h2><p>All schemes implemented by this package make use of the RLWE setting. In particular, the security assumption underlying the protocols is the general <a href="https://en.wikipedia.org/wiki/Ring_learning_with_errors">Ring Learning With Errors</a> problem and the primary mathematical object of interest is the ring</p><div>\[    \mathscr{R}_q = \frac{(\mathbb{Z}/q \mathbb{Z})[x]}{\Phi_m(x)}\]</div><p>where <span>$\Phi_m$</span> is the m-th cyclotomic polynomial. In particular, we may represent this ring as polynomials with coefficients in <span>$\mathbb{Z}/q \mathbb{Z}$</span>, of degree less than <span>$n = deg(\Phi_m(x)) = \phi(m)$</span> where <span>$\phi$</span> is the Euler <a href="man/background/@ref Primes.totient"><code>totient</code></a> function. Alternatively we may think of <span>$\mathscr{R}_q$</span> as the residue ring mod q of the m-th cyclotomic ring of integers <span>$\mathscr{R} = \mathbb{Z} / \Phi_m(x)$</span>. We shall call <span>$q$</span> the ciphertext modulus, and <span>$n$</span> the ring dimension. In general we will take the ciphertext modulus to be a large prime or a product of somewhat large primes (the correctness of the crytopgraphic scheme depends on choosing <code>q</code> such that the sum of the number of bits of the prime factors is sufficiently large).</p><p>This definition may seem a bit abstract at first, but since it is the primary mathematical object of interest, it is import that we get acquianted with it a bit. Luckily for us, it is quite easy to play with these definitions using the <a href="https://github.com/Nemocas/Nemo.jl">Nemo.jl</a> stack of packages:</p><pre><code class="language-julia">using Nemo

# ‚Ñ§, the ring of integers
‚Ñ§ = Nemo.ZZ

# ‚Ñ§[x], the ring of polynomials with integer coefficients
‚Ñ§x, x = PolynomialRing(‚Ñ§, &quot;x&quot;)

# Nemo provides a function to compute m-th cyclotomics for us
Œ¶(m, x) = Nemo.cyclotomic(m, x)

# Let&#39;s take a look at first 10 cyclotomics
[Œ¶(m, x) for m = 1:10]

# output
10-element Array{fmpz_poly,1}:
 x-1
 x+1
 x^2+x+1
 x^2+1
 x^4+x^3+x^2+x+1
 x^2-x+1
 x^6+x^5+x^4+x^3+x^2+x+1
 x^4+1
 x^6+x^3+1
 x^4-x^3+x^2-x+1</code></pre><p>There are two practical observations worth taking away from this exercise.</p><ol><li>The degree of the m-th cyclotomic polynomial is indeed given by the Euler totient function:</li></ol><pre><code class="language-julia">using Primes

œï(n) = Primes.totient(n)

[œï(m) for m = 1:10]

# output
10-element Array{Int64,1}:
 1
 1
 2
 2
 4
 2
 6
 4
 6
 4</code></pre><ol><li>When <span>$m$</span> is a power of two, the polynomial will have the form <span>$x^{m/2} + 1$</span>. This holds generally, but let&#39;s just do the first couple of powers of two as examples:</li></ol><pre><code class="language-julia-repl">julia&gt; [Œ¶(2^i, x) for i = 1:13]
13-element Array{fmpz_poly,1}:
 x+1
 x^2+1
 x^4+1
 x^8+1
 x^16+1
 x^32+1
 x^64+1
 x^128+1
 x^256+1
 x^512+1
 x^1024+1
 x^2048+1
 x^4096+1</code></pre><p>For reasons having to do with the security properties of the resulting scheme, <code>m</code> will generally be either prime or a power of two.</p><h2><a class="nav-anchor" id="Power-of-two-cyclotomic-rings-1" href="#Power-of-two-cyclotomic-rings-1">Power of two cyclotomic rings</a></h2><h3><a class="nav-anchor" id="Using-Nemo.jl-/-Negacyclic-convolutions-1" href="#Using-Nemo.jl-/-Negacyclic-convolutions-1">Using Nemo.jl / Negacyclic convolutions</a></h3><p>Because of their importance to practical implementations, this package contains a custom implementation of power-of-two cyclotomic rings. However, before we get there, let&#39;s build this ring manually using Nemo. To be concrete, we will chose <code>m=2^3=8</code> (i.e. <code>n=2^2=4</code>) and <code>q=97</code>[1]:</p><pre><code class="language-julia">m = 2^3
q = 97

# ‚Ñ§q = ‚Ñ§/q‚Ñ§, the ring of integers mod `q`
# Note that in this case `q` is a prime, so ‚Ñ§q = ùîΩq is a finite field
‚Ñ§q = ResidueRing(‚Ñ§, q)

# (‚Ñ§/q‚Ñ§)[x], the ring of polynomials with integer coefficients mod `q`
‚Ñ§qx, xq = PolynomialRing(‚Ñ§q, &quot;x&quot;)

# Finally our ring of interest (‚Ñ§/q‚Ñ§)[x]/Œ¶_m(x)
‚Ñõ = ResidueRing(‚Ñ§qx, Œ¶(m, x))

# output
Residue ring of Univariate Polynomial Ring in x over Integers modulo 31 modulo x^4+1</code></pre><p>Now that we have the ring, let&#39;s construct a few polynomials in it.</p><pre><code class="language-julia">p1 = ‚Ñõ(x+1)
p2 = ‚Ñõ(x^3)
p3 = ‚Ñõ(4)
p4 = ‚Ñõ(5)</code></pre><p>Note in particular that we have an embedding of <span>$\mathbb{F}_q$</span> into <span>$\mathscr{R}$</span> by simply embedding into the <code>x^0 = 1</code> term of the polynomial. Multiplying these polynomials works as we&#39;d expect:</p><pre><code class="language-julia-repl">julia&gt; p3*p4
20</code></pre><p>and similarly polynomials whose product is of degree smaller than the degree of the cyclotomic polynomial will behave as expected:</p><pre><code class="language-julia-repl">julia&gt; p1^2
x^2+2*x+1</code></pre><p>but once we reach the degree of the cyclotomic, we will wrap around</p><pre><code class="language-julia-repl">julia&gt; p2*p1
x^3+96</code></pre><p>which is expected since <span>$x^4 \equiv -1 (mod x^4 + 1)$</span> and</p><div>\[(x+1)(x^3) = x^4 + x^3 \equiv x^3 - 1 \equiv x^3 + 96 mod (x^4 + 1, 97)\]</div><p>As we can see the behavior (at least for power of two cyclotomics) is fairly simple: Once our multiplication wraps around, we simply subtract the resulting coefficients starting at <code>x^0</code> again. The resulting operation is thus essentially a cyclic convolution, except that wrapping around introduces an extra <code>-</code> sign. We thus refer to this operation as a <strong>negacyclic</strong> convolution.</p><h3><a class="nav-anchor" id="The-NegacyclicRing-type-1" href="#The-NegacyclicRing-type-1">The <code>NegacyclicRing</code> type</a></h3><p>Because of the importance of power of two cyclotomics rings (i.e. negacyclic rings), this package comes with a specialized implementation of these rings that provides improved performance over the generic version using Nemo (as well as being written in pure Julia). The <a href="man/background/@ref"><code>NegacyclicRing</code></a> type provides the entrypoint for this functionality:</p><pre><code class="language-none">using GaloisFields
ùîΩ‚Çâ‚Çá = GaloisField(q)
‚Ñõ = NegacyclicRing{ùîΩ‚Çâ‚Çá, m √∑ 2}()

# output
NegacyclicRing{ùîΩ‚Çâ‚Çá,4}(33)</code></pre><p>We can repeat our experiment from above</p><pre><code class="language-julia">using OffsetArrays
O(a) = OffsetArray(ùîΩ‚Çâ‚Çá.(a), 0:3)
p1 = ‚Ñõ(O([1, 1, 0, 0])) # x + 1
p2 = ‚Ñõ(O([0, 0, 0, 1])) # x^3
p3 = ‚Ñõ(O([4, 0, 0, 0])) # 4
p4 = ‚Ñõ(O([5, 0, 0, 0])) # 5</code></pre><p>We can already see from the construction that <code>NegacyclicRing</code> ring uses a different representation of the ring. Instead of polynomials, we think of ring elements as arrays with a funny multiplication law (of course the two representations are completely isomorphic). This is purely for convenience of presentation when <code>m</code> is large (large arrays of numbers print more conveniently than large sums of coefficients times <span>$x^i$</span>). The results are analogous to the what we obtained above using Nemo:</p><pre><code class="language-julia-repl">julia&gt; [p3*p4, p1^2, p1*p2]
3-element Array{ToyFHE.NTT.RingElement{NegacyclicRing{ùîΩ‚Çâ‚Çá,4}(33),ùîΩ‚Çâ‚Çá,Array{ùîΩ‚Çâ‚Çá,1}},1}:
 [20, 0, 0, 0]
 [1, 2, 1, 0]
 [96, 0, 0, 1]</code></pre><p>Internally, the <code>NegacyclicRing</code> type uses an analogue of the fast fourier transform algorithm over finite fields to turn the (negacyclic) convolutions into pointwise multiplications, thus performing these computations in <code>\mathcal{O}(n log n)</code> time rather than <code>\mathcal{O}(n^2)</code> time. This transformation is known as the negacyclic number theoretic transform or fermat number transform. See the corresponding <a href="man/background/@ref nntt"><code>section in the mathematical prerequisites chapter</code></a> for details.</p><p>[1] Note that <code>m</code> was chosen arbitrarily, but <code>q</code> was chosen to be the first prime that such that <code>m</code> divies <code>q-1</code> (we will see later why this criterion is important to allow a performant specialized implementation).</p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Cryptography background</span></a><a class="next" href="../fhe/"><span class="direction">Next</span><span class="title">Cryptographic Schemes for FHE</span></a></footer></article></body></html>
