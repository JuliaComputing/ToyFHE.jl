var documenterSearchIndex = {"docs":
[{"location":"man/background/#Cryptography-background-1","page":"Cryptography background","title":"Cryptography background","text":"","category":"section"},{"location":"man/background/#","page":"Cryptography background","title":"Cryptography background","text":"This chapter of the manual provides an overview of the various cryptographic schemes implemented by this package. It is recommended that all users go through this entire chapter. Even those familiar with the cryptographic schemes in question, will find this chapter of value as a gentle usage introduction for the underyling mathematical primitives, as well as hopefully a straightforward statement of the actual cryptographic protocol and notational conventions used in this package (since they sometimes differ between different papers in the literature.)","category":"page"},{"location":"man/background/#","page":"Cryptography background","title":"Cryptography background","text":"Pages = [\"background/rlwe.md\", \"background/fhe.md\"]\nDepth = 2","category":"page"},{"location":"man/background/rlwe/#Ring-LWE-and-‚Ñõq-1","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"","category":"section"},{"location":"man/background/rlwe/#The-ring-of-m-th-cyclotomic-integers-mod-q-1","page":"Ring LWE and ‚Ñõq","title":"The ring of m-th cyclotomic integers mod q","text":"","category":"section"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"All schemes implemented by this package make use of the RLWE setting. In particular, the security assumption underlying the protocols is the general Ring Learning With Errors problem and the primary mathematical object of interest is the ring","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"    mathscrR_q = frac(mathbbZq mathbbZ)xPhi_m(x)","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"where Phi_m is the m-th cyclotomic polynomial. In particular, we may represent this ring as polynomials with coefficients in mathbbZq mathbbZ, of degree less than n = deg(Phi_m(x)) = phi(m) where phi is the Euler totient function. Alternatively we may think of mathscrR_q as the residue ring mod q of the m-th cyclotomic ring of integers mathscrR = mathbbZ  Phi_m(x). We shall call q the ciphertext modulus, and n the ring dimension. In general we will take the ciphertext modulus to be a large prime or a product of somewhat large primes (the correctness of the crytopgraphic scheme depends on choosing q such that the sum of the number of bits of the prime factors is sufficiently large).","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"This definition may seem a bit abstract at first, but since it is the primary mathematical object of interest, it is import that we get acquianted with it a bit. Luckily for us, it is quite easy to play with these definitions using the Nemo.jl stack of packages:","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"using Nemo\n\n# ‚Ñ§, the ring of integers\n‚Ñ§ = Nemo.ZZ\n\n# ‚Ñ§[x], the ring of polynomials with integer coefficients\n‚Ñ§x, x = PolynomialRing(‚Ñ§, \"x\")\n\n# Nemo provides a function to compute m-th cyclotomics for us\nŒ¶(m, x) = Nemo.cyclotomic(m, x)\n\n# Let's take a look at first 10 cyclotomics\n[Œ¶(m, x) for m = 1:10]\n\n# output\n10-element Array{fmpz_poly,1}:\n x-1\n x+1\n x^2+x+1\n x^2+1\n x^4+x^3+x^2+x+1\n x^2-x+1\n x^6+x^5+x^4+x^3+x^2+x+1\n x^4+1\n x^6+x^3+1\n x^4-x^3+x^2-x+1","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"There are two practical observations worth taking away from this exercise.","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"The degree of the m-th cyclotomic polynomial is indeed given by the Euler totient function:","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"using Primes\n\nœï(n) = Primes.totient(n)\n\n[œï(m) for m = 1:10]\n\n# output\n10-element Array{Int64,1}:\n 1\n 1\n 2\n 2\n 4\n 2\n 6\n 4\n 6\n 4","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"When m is a power of two, the polynomial will have the form x^m2 + 1. This holds generally, but let's just do the first couple of powers of two as examples:","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"julia> [Œ¶(2^i, x) for i = 1:13]\n13-element Array{fmpz_poly,1}:\n x+1\n x^2+1\n x^4+1\n x^8+1\n x^16+1\n x^32+1\n x^64+1\n x^128+1\n x^256+1\n x^512+1\n x^1024+1\n x^2048+1\n x^4096+1","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"For reasons having to do with the security properties of the resulting scheme, m will generally be either prime or a power of two.","category":"page"},{"location":"man/background/rlwe/#Power-of-two-cyclotomic-rings-1","page":"Ring LWE and ‚Ñõq","title":"Power of two cyclotomic rings","text":"","category":"section"},{"location":"man/background/rlwe/#Using-Nemo.jl-/-Negacyclic-convolutions-1","page":"Ring LWE and ‚Ñõq","title":"Using Nemo.jl / Negacyclic convolutions","text":"","category":"section"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"Because of their importance to practical implementations, this package contains a custom implementation of power-of-two cyclotomic rings. However, before we get there, let's build this ring manually using Nemo. To be concrete, we will chose m=2^3=8 (i.e. n=2^2=4) and q=97[1]:","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"m = 2^3\nq = 97\n\n# ‚Ñ§q = ‚Ñ§/q‚Ñ§, the ring of integers mod `q`\n# Note that in this case `q` is a prime, so ‚Ñ§q = ùîΩq is a finite field\n‚Ñ§q = ResidueRing(‚Ñ§, q)\n\n# (‚Ñ§/q‚Ñ§)[x], the ring of polynomials with integer coefficients mod `q`\n‚Ñ§qx, xq = PolynomialRing(‚Ñ§q, \"x\")\n\n# Finally our ring of interest (‚Ñ§/q‚Ñ§)[x]/Œ¶_m(x)\n‚Ñõ = ResidueRing(‚Ñ§qx, Œ¶(m, x))\n\n# output\nResidue ring of Univariate Polynomial Ring in x over Integers modulo 31 modulo x^4+1","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"Now that we have the ring, let's construct a few polynomials in it.","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"p1 = ‚Ñõ(x+1)\np2 = ‚Ñõ(x^3)\np3 = ‚Ñõ(4)\np4 = ‚Ñõ(5)","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"Note in particular that we have an embedding of mathbbF_q into mathscrR by simply embedding into the x^0 = 1 term of the polynomial. Multiplying these polynomials works as we'd expect:","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"julia> p3*p4\n20","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"and similarly polynomials whose product is of degree smaller than the degree of the cyclotomic polynomial will behave as expected:","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"julia> p1^2\nx^2+2*x+1","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"but once we reach the degree of the cyclotomic, we will wrap around","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"julia> p2*p1\nx^3+96","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"which is expected since x^4 equiv -1 (mod x^4 + 1) and","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"(x+1)(x^3) = x^4 + x^3 equiv x^3 - 1 equiv x^3 + 96 mod (x^4 + 1 97)","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"As we can see the behavior (at least for power of two cyclotomics) is fairly simple: Once our multiplication wraps around, we simply subtract the resulting coefficients starting at x^0 again. The resulting operation is thus essentially a cyclic convolution, except that wrapping around introduces an extra - sign. We thus refer to this operation as a negacyclic convolution.","category":"page"},{"location":"man/background/rlwe/#The-NegacyclicRing-type-1","page":"Ring LWE and ‚Ñõq","title":"The NegacyclicRing type","text":"","category":"section"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"Because of the importance of power of two cyclotomics rings (i.e. negacyclic rings), this package comes with a specialized implementation of these rings that provides improved performance over the generic version using Nemo (as well as being written in pure Julia). The NegacyclicRing type provides the entrypoint for this functionality:","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"using GaloisFields\nùîΩ‚Çâ‚Çá = GaloisField(q)\n‚Ñõ = NegacyclicRing{ùîΩ‚Çâ‚Çá, m √∑ 2}()\n\n# output\nNegacyclicRing{ùîΩ‚Çâ‚Çá,4}(33)","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"We can repeat our experiment from above","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"using OffsetArrays\nO(a) = OffsetArray(ùîΩ‚Çâ‚Çá.(a), 0:3)\np1 = ‚Ñõ(O([1, 1, 0, 0])) # x + 1\np2 = ‚Ñõ(O([0, 0, 0, 1])) # x^3\np3 = ‚Ñõ(O([4, 0, 0, 0])) # 4\np4 = ‚Ñõ(O([5, 0, 0, 0])) # 5","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"We can already see from the construction that NegacyclicRing ring uses a different representation of the ring. Instead of polynomials, we think of ring elements as arrays with a funny multiplication law (of course the two representations are completely isomorphic). This is purely for convenience of presentation when m is large (large arrays of numbers print more conveniently than large sums of coefficients times x^i). The results are analogous to the what we obtained above using Nemo:","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"julia> [p3*p4, p1^2, p1*p2]\n3-element Array{ToyFHE.NTT.RingElement{NegacyclicRing{ùîΩ‚Çâ‚Çá,4}(33),ùîΩ‚Çâ‚Çá,Array{ùîΩ‚Çâ‚Çá,1}},1}:\n [20, 0, 0, 0]\n [1, 2, 1, 0]\n [96, 0, 0, 1]","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"Internally, the NegacyclicRing type uses an analogue of the fast fourier transform algorithm over finite fields to turn the (negacyclic) convolutions into pointwise multiplications, thus performing these computations in \\mathcal{O}(n log n) time rather than \\mathcal{O}(n^2) time. This transformation is known as the negacyclic number theoretic transform or fermat number transform. See the corresponding section in the mathematical prerequisites chapter for details.","category":"page"},{"location":"man/background/rlwe/#","page":"Ring LWE and ‚Ñõq","title":"Ring LWE and ‚Ñõq","text":"[1] Note that m was chosen arbitrarily, but q was chosen to be the first prime that such that m divies q-1 (we will see later why this criterion is important to allow a performant specialized implementation).","category":"page"},{"location":"man/encoding/#Ciphertext-Encodings-1","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"","category":"section"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"In the background section, we learned how to homomorphically perform operations over the ring mathscrR_q. However, in general we may want to perform computations over mathematical spaces other than mathscrR_q. To do, we must devise a scheme and selection of parameters p,q,m that allow us to efficiently encode our object of interested into an element of mathscrR_q such that arithmetic in mathscrR_q corresponds to whatever computation we're interested in for the encoded object. In this section we shall see several strategies for encoding numbers into single ciphertexts, while in the next section we shall consider the encoding of more complex higher level objects into multiple ciphertexts. To make the above mentioned parameterization explicit, we will use the notation mathscrR_qpm in this section rather than leaving the parameters pm implicit.","category":"page"},{"location":"man/encoding/#Scalar-Encodings-1","page":"Ciphertext Encodings","title":"Scalar Encodings","text":"","category":"section"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"As noted in the background section, there is a natural embedding of mathbbZp mathbbZ into mathscrR_qpm (for arbitrary q,m, though of course we require q>p and security considerations will in general force larger values).","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"‚Ñõ = NegacyclicRing{GaloisField(7), 2}(nothing)\np1, p2 = zero(‚Ñõ), zero(‚Ñõ)\np1[0] = 3\np2[0] = 4\np1*p2\n\n# output\n2-element ToyFHE.NTT.RingElement{NegacyclicRing{ùîΩ‚Çá,2}(0),ùîΩ‚Çá,Array{ùîΩ‚Çá,1}} with indices 0:1:\n 5\n 0","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"To make the use of this encoding explicit, there is an encoding wrapper type that simply perfoms this encoding (in this example with UInt8, which in Julia is defined as mathbbZ256mathbbZ)","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"‚Ñõ = NegacyclicRing{UInt8, 2}(nothing)\na, b = ScalarEncoding{UInt8}(zero(‚Ñõ)), ScalarEncoding{UInt8}(zero(‚Ñõ))\na[] = 3\nb[] = 15\nconvert(RingElement, a) * convert(RingElement, b)\n\n# output\n2-element RingElement{NegacyclicRing{UInt8,2}(0x00),UInt8,Array{UInt8,1}} with indices 0:1:\n 0x2d\n 0x00","category":"page"},{"location":"man/encoding/#SIMD-Encoding-1","page":"Ciphertext Encodings","title":"SIMD Encoding","text":"","category":"section"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"In general, the ring dimension n will be quite large (e.g. 2048, 4096 for small examples, or even larger for programs of practical interest). As such, it seems wasteful to only use the lowest coefficient for computation, while the others just sit around warming the planet. And of we can always use the other coefficients if the operations if we're ok with mathscrR_q arithmetic. However, in practical operations we are much more interested in pointwise operations on vectors rater than negacyclic convolutions of vectors. There are several techniques to remidy this disconnect and let us treat a single mathscrR_q as multiple independent plaintexts with both addition and multiplication being applied elementwise, similar to SIMD lanes in a modern CPU or GPU. In the literature, these independent plaintexts are generally referred to as plaintext \"slots\". In practice, how to go between the vector of slots and an element in mathscrR_q depends on the which parameter domain we're in, though they are all just applications of the chinese remainder theorem for polynomials.","category":"page"},{"location":"man/encoding/#SIMD-Encoding-using-NTT-1","page":"Ciphertext Encodings","title":"SIMD Encoding using NTT","text":"","category":"section"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"You may recall from the background section that we are using a mathematical trick known as the Number Theory Transform (NTT) to efficiently perform negacyclic convolutions as pointwise multiplications. Naturally, we can also apply this trick in reverse and use the fact that we can perform negacyclic convolutions to obtain a method to perform element-wise multiplications. The catch here is that for this to work, we need to be able to do negacyclic convolutions in both the plaintext space and the ciphertext space (we always need to be able to do the latter, but in the general scheme, we can chose the plaintext modulus p). Since the ring dimension is often quite large, this method may not be applicable to values of p of interest, or may force us to use a value of p larger than we intended. Recall thus the condition for being able to apply the NTT:","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"If the prime factors of p are `p = p‚ÇÅ ‚ãØ p‚±º`, the NTT exists iff the `p·µ¢` are all distrinct and 2n divides `p·µ¢` for all `i` in `1:j`.","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"Since in practice N is generally in the thousands to tens of thousands and is a power of two, the available values of p is fairly restricted. Nevertheless if the plaintext space of interest is e.g. machine integers (of 16, 32 or 64 bit width) and lack of overflow is guaranteed, this encoding may be an attractive option. In particular note that 65537 = 2^16 + 1 is prime and can thus be encoded with minimal overhead. Note further that this methods gives us exactly n plaintext slots, so is a very efficient method of encoding such integers into a ciphertext.","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"This package provides a convenience wrapper that acts as a view into a plaintext, but implicity performs the NTT:","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"‚Ñõ = NegacyclicRing{GaloisField(65537), 2048}()\n\na = SlotEncoding(zero(‚Ñõ))\na[0:9] = 1:10\n\nb = SlotEncoding(zero(‚Ñõ))\nb[:] .= 10\n\nSlotEncoding(convert(RingElement, a) * convert(RingElement, b))[0:10]\n\n# output\n11-element Array{ùîΩ‚ÇÜ‚ÇÖ‚ÇÖ‚ÇÉ‚Çá,1}:\n  10\n  20\n  30\n  40\n  50\n  60\n  70\n  80\n  90\n 100\n   0","category":"page"},{"location":"man/encoding/#SIMD-Encoding-over-general-cyclotomics-1","page":"Ciphertext Encodings","title":"SIMD Encoding over general cyclotomics","text":"","category":"section"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"The example in the previous section is a special case of a more general technique: The polynomial chinese remainder theorem. Just like its analogue for integers (which is discussed in the mathematical background and used for the CRT encoding of integer coefficients), if a polynomial f has coprime factors f = f‚ÇÅ ‚ãØ f‚±º, then there is an ismorphism between polynomials mod f and polynomials mod each of the factors. As a result, if Phi_m(x) in mathbbZ_px splits as Phi_m(x) = f_1(x) cdots f_j(x), this induces an ismorphism","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"mathbbZ_pxPhi_m(x) cong mathbbZ_pxf_1(x) times cdots times mathbbZ_pxf_j(x)","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"We can now see the correspondence between this definition and the method of the previous subection. Recall that one of the definitions of the m-th cyclotomic polynomial is","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"Phi_m(x) = Pi_k=1^phi(m) (x - zeta_mk)","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"where the zeta_mk are the m-th primitive roots of unity. The definition of the previous section simply requires that zeta_mk in mathbbZ_p (i.e. that mathbbZ_p contains the m-th primitive roots of unity), and so by the chinese remainder theorem our ring factors into phi(m) = n copies of mathbbZ_p. So now let us consider what happens when the setting of the previous section does not apply.","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"For concreteness, let us suppose we choose m = 7,p=2. We have (for a more general introduction to cyclotomics using Nemo, see the RLWE section of the background):","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"using Nemo\n‚Ñ§ = Nemo.ZZ\n‚Ñ§x, x = PolynomialRing(‚Ñ§, \"x\")\n‚Ñ§px, xp = PolynomialRing(ResidueRing(‚Ñ§, 2), \"x\")\nŒ¶(m, x) = Nemo.cyclotomic(m, x)\n\nNemo.factor(‚Ñ§px(Œ¶(7, x)))\n\n# output\n\n1 * (x^3+x+1) * (x^3+x^2+1)","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"Thus, we see that mathbbF_2Phi_7(x) cong mathbbF_2(x^3 + x + 1) times mathbbF_2(x^3 + x^2 + 1) cong mathbbF_2^3^2 (i.e. two copies of the finite field mathbbF_2^3). It is these two copies that we can independently address in a SIMD manner. Of course we may also use any subfields of this factorization, and in particular we may use the subfield mathbbF_2 if we want to perform binary arithmetic.","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"In summary: We get one copy of mathbbF_p^d for every distinct irreducible factor of Phi_m(x) over mathbbF_p.","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"note: Note\nThe field mathbbF_p^r and the ring mathbbZp^r mathbbZ are different. The latter may be of interest when emulating arithmetic such as UInt8 with overflow semantics matching that of standard Julia (i.e. the standard Julia UInt8 type is equivalent to mathbbZ256 mathbbZ). We shall see how to construct an encoding for such a ring in the next section.","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"The PolyCRTEncoding type knows how to perform these isomorphisms and will automatically apply them when possible:","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"const ‚Ñ§ = ZZ\nconst ‚Ñ§x, x = ZZ[\"x\"]\nconst ‚Ñ§px, xp = ResidueRing(ZZ, 2)[\"xp\"]\n‚Ñõ = ResidueRing(‚Ñ§px, cyclotomic(7, x))\n\nplain = PolyCRTEncoding(zero(‚Ñõ))\nŒ≤ = GaloisFields.gen(eltype(plain))\n\nplain[1] = Œ≤+1\nplain[2] = Œ≤^2+1\n\np = convert(‚Ñõ, plain)\n\n# output\nxp^4+xp^3+xp^2+xp","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"And of course as before it works the inverse way also:","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"julia> PolyCRTEncoding(‚Ñõ(xp^4+xp^3+xp^2+xp))\n2-element PolyCRTEncoding{ùîΩ‚Çà}:\n   Œ≤ + 1\n Œ≤^2 + 1","category":"page"},{"location":"man/encoding/#SIMD-Encoding-from-Hensel-lifting-1","page":"Ciphertext Encodings","title":"SIMD Encoding from Hensel lifting","text":"","category":"section"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"In the previous subsection, we saw how to encode values in extension fields of the finite field mathbbF_p. In this section, we shall see how to SIMD encode plaintext values from the ring mathbbZp^r mathbbZ using Hensel Lifting. The key fact of Hensel's lemma is that we may \"lift\" a factorization of f over mathbbF_p to a factorization over the larger ring mathbbZp^r mathbbZ (in this case for p=2, r=8, p^r=256)","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"julia> factors = collect(keys(Hecke.factor_mod_pk(Œ¶(7, x), 2, 8)))\n2-element Array{fmpz_poly,1}:\n x^3-90*x^2-91*x-1\n x^3+91*x^2+90*x-1","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"which is the lift of the factorization we know from before:","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"julia> ‚Ñ§px.(factors)\n2-element Array{nmod_poly,1}:\n x^3+x+1\n x^3+x^2+1","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"The CRT encoding works much the same way:","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"‚Ñ§pkx = ResidueRing(ZZ, 256)[\"x\"][1]\nencoded = AbstractAlgebra.crt(‚Ñ§pkx.(Int.([0x10, 0x20])), ‚Ñ§pkx.(factors))\n\n# output\n48*x^4+48*x^2+48*x+48","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"julia> mod(encoded, ‚Ñ§pkx(factors[1]))\n16\n\njulia> mod(encoded, ‚Ñ§pkx(factors[2]))\n32","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"Of course, as before, the PolyCRTEncoding type will perform all this work automatically:","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"const ‚Ñ§ = Nemo.ZZ\nconst ‚Ñ§x, x = ‚Ñ§[\"x\"]\nconst ‚Ñ§px, xp = ResidueRing(‚Ñ§, 256)[\"xp\"]\n‚Ñõ = ResidueRing(‚Ñ§px, cyclotomic(7, x))\n\nplain = PolyCRTEncoding(zero(‚Ñõ))\n\nplain[1] = 0x10\nplain[2] = 0x20\n\np = convert(‚Ñõ, plain)\n\n# output\n48*xp^4+48*xp^2+48*xp+48","category":"page"},{"location":"man/encoding/#Encoding-Summary-1","page":"Ciphertext Encodings","title":"Encoding Summary","text":"","category":"section"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"While each of the three SIMD approaches outlined above is an example of the same underlying mathematical principle, they have fastly different performance characteristics and supported parameter ranges. The following table provides a summary:","category":"page"},{"location":"man/encoding/#","page":"Ciphertext Encodings","title":"Ciphertext Encodings","text":"Method Plaintext Space Number of Slots Parameter Constraints\nNTT mathbbZp 1 None\nSIMD NTT mathbbF_p n p prime, gcd(p-12n)==2n\nGeneric CRT mathbbF_p^d l p prime, phi_m(n)=l*d, Phi_m factors over mathbbF_p\n+ Hensel mathbbZ_p^kxf_i(x) l p prime, phi_m(n)=l*d, Phi_m factors over mathbbF_p","category":"page"},{"location":"man/multi-encodings/#Multi-Ciphertext-encodings-1","page":"Multi-Ciphertext encodings","title":"Multi-Ciphertext encodings","text":"","category":"section"},{"location":"man/ckks/#The-CKKS-encryption-scheme-1","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"","category":"section"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"The CKKS scheme may seem a bit strange at first, but it is actually a quite straightforward extension of the ideas we have already seen. Rather than describing what it is, let us explore how one might come to making the same choices.","category":"page"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"Let's say you've just finished writing for wonderful implementation of BGV, or BFV. Basking in the glory of your accomplishments you proudly show off encrypted integer multiplies to your boss. \"Look\", you say excitedly, \"it multiplied those numbers even though they were encrypted. It even did a few thousand of those at once.\" \"That's nice\", your boss replies \"now make it do ‚Ñù; ‚Ñ§ is so last century\". Discouraged you return to your desk - there goes the weekend.","category":"page"},{"location":"man/ckks/#Fixed-point-encoding-1","page":"The CKKS encryption scheme","title":"Fixed point encoding","text":"","category":"section"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"What now? A faint memory dawns of the dark ages before IEEE754. Back when the world was black and white and the real numbers were fixed point. You dust off the trusty fixed point number library and try it:","category":"page"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"using ToyFHE\nusing FixedPointNumbers\n\nparams = BFVParams(\n    65537, # plaintext modulus\n    ; eval_mult_count = 1\n)\nkp = keygen(params)\n\na = ScalarEncoding{Int16}(zero(plaintext_space(params)))\na[] = reinterpret(Int16, 1.5Q11f4)\n\nb = ScalarEncoding{Int16}(zero(plaintext_space(params)))\nb[] = reinterpret(Int16, 2.0Q11f4)\n\nc1, c2 = encrypt.(kp, (a, b))\ny = c1*c2\nreinterpret(Fixed{Int16,8}, convert(Integer, decrypt(kp, y)[0]) % Int16)\n\n# output\n\n3.0Q7f8","category":"page"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"Hey that worked! One particular thing to note is that multiplication increased the size of the fraction. We started off with a Q11f4 (i.e. 11 quotient bits, 4 fraction bits) and ended up with a Q7f8. Managing the size of the fraction will become important. We'll see that below.","category":"page"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"Alright, let's keep going. Can we do SIMD?","category":"page"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"a = SlotEncoding(zero(plaintext_space(params)))\nb = SlotEncoding(zero(plaintext_space(params)))\nplain_range = LinRange(0.0, 2.0, 4096)\na[:] .= reinterpret.(Int16, Fixed{Int16,6}.(OffsetArray((plain_range, 0:4095)))\nb[:] .= reinterpret(Int16, Fixed{Int16,6}(2.0Q11f4))\n\n\nc1, c2 = encrypt.(kp, (a, b))\ny = c1*c2\n# Let's just look at every fourth output\nreinterpret.(Fixed{Int16,12}, convert.(Integer, SlotEncoding(decrypt(kp, y))) .% Int16)[1:4:end]\n\n# output\n512-element Array{Q3f12,1} with eltype Fixed{Int16,12}:\n 0.0Q3f12\n 0.0Q3f12\n 0.0312Q3f12\n 0.0312Q3f12\n 0.0312Q3f12\n 0.0312Q3f12\n ‚ãÆ\n 3.9688Q3f12\n 3.9688Q3f12\n 4.0Q3f12\n 4.0Q3f12","category":"page"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"Ok, that kinda works, but even with 6 bits in the fraction, we don't really have enough precision to take advantage of the whole 4096 plaintext slots we have. Can we come up with something better?","category":"page"},{"location":"man/ckks/#Noisy-encoding-1","page":"The CKKS encryption scheme","title":"Noisy encoding","text":"","category":"section"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"So here comes one of the main ideas of CKKS: What if instead of letting all those lower bits just sit around and accumulate noise, we used them in the computation? Sure, they'll get gradually overwritten by noise, but at least we can take advantage of the higher precision in the first couple intermediate multiplications. Let's see what we can do. We define our new scheme (partially extracted from the ckks.jl source file):","category":"page"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"struct CKKSParams <: SHEShemeParams\n    # The Cypertext ring over which operations are performed\n    ‚Ñõ\n    # The big ring used during multiplication\n    ‚Ñõbig\n    relin_window\n    œÉ\nend\nscheme_name(p::Type{CKKSParams}) = \"CKKS\"\n\n# Just, like, put the plaintext right there\nœÄ‚Åª¬π(params::CKKSParams, plaintext) = params.‚Ñõ(plaintext)\nœÄ(params::CKKSParams, b) = b","category":"page"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"so let's try it:","category":"page"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"ckksp = CKKSParams(params.‚Ñõ, params.‚Ñõbig, params.relin_window, params.œÉ)\nkp = keygen(ckksp)\na = ScalarEncoding{eltype(params.‚Ñõ)}(zero(plaintext_space(ckksp)))\na[] = reinterpret(Int128, Fixed{Int128, 35}(plain_range[2]))\n\nb = ScalarEncoding{eltype(params.‚Ñõ)}(zero(plaintext_space(ckksp)))\nb[] = reinterpret(Int128, Fixed{Int128, 35}(2.0))\n\nc1, c2 = encrypt.(kp, (a, b))\ny = c1*c2\nreinterpret(Fixed{Int128, 70}, convert(Integer, ScalarEncoding{eltype(params.‚Ñõ)}(decrypt(kp, y))[]))\n\n# output\n0.0009768583554942668Q57f70","category":"page"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"Alright, we're getting there. Recall from before that when we tried this in exact arithmetic, we just got it rounded to 0.0Q3f12. Here we're much closer to something usable. The correctly rounded answer would be:","category":"page"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"julia> plain_range[2]*2.0\n0.0009768009768009768","category":"page"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"so we've got about four significant digits of precision here while still using the exact same ring as before (so the performance is the same) - not bad. Let's just quickly try the same thing in SIMD and then we're off to the beach:","category":"page"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"a = SlotEncoding(zero(plaintext_space(ckksp)))\nb = SlotEncoding(zero(plaintext_space(ckksp)))\n\na[:] .= reinterpret.(Int128, Fixed{Int128, 35}.(OffsetArray(plain_range, 0:4095)))\nb[:] .= reinterpret(Int128, Fixed{Int128, 35}(2.0Q11f4))\n\nc1, c2 = encrypt.(kp, (a, b))\ny = c1*c2\nreinterpret.(Fixed{Int128, 70}, convert.(Integer, SlotEncoding(decrypt(kp, y))))\n\n# output\n4096-element OffsetArray(::Array{Q57f70,1}, 0:4095) with eltype Fixed{Int128,70} with indices 0:4095:\n   403.04509382624775Q57f70\n  9155.89125414592Q57f70\n  6508.182113138049Q57f70\n  4818.847233626708Q57f70\n  3260.3910792678466Q57f70\n 10573.82362550682Q57f70\n      ‚ãÆ","category":"page"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"Wait what happend? We did all the same things as before. Everything should work... Noooo!!!! drops picnic basket. Well, recall from the encoding section how our slot encoding works: We're doing a finite field analogue of the FFT. And it turns out that that procedure is particularly sensitive to errors, so while we were ok with the round off errors in the simple scalar example above, once we start doing ffts everything falls apart. What can we do?","category":"page"},{"location":"man/ckks/#Complex-FFT-1","page":"The CKKS encryption scheme","title":"Complex FFT","text":"","category":"section"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"We get to the second major idea in CKKS: We permute the order of the fixed point encoding and the FFT. In particular, recall the operation that is native to the scheme: A negacyclic convolution of integers. With our fixed point encoding, we get a negacyclic convolution of reals. What can we do with that? A lot it turns out. In the same say way, we can turn a convolution in a finite field negacyclic (by multiplying every element by a power of the square root of the appropriate root of unity), we can do the same in the complex domain and obtain the negacyclic convolution theorem (for complex numbers):","category":"page"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"f cdot g = psi^-1(mathscrF^-1(mathscrF(psi(f)) *_neg mathscrF(psi(f))))","category":"page"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"The insight here is that the complex fft is more robuts to roundoff errors than doing the fft in the finite field. There's one small catch. We said we can do a real negacyclic convolution, but in general, our convolution needs to operate on complex coefficients. Can we work around that? As it turns out, we can. Suppose we take image of mathbbR^n under psi^-1 circ mathscrF^-1. What do we get? As it turns out get get the subspace mathbbH subset mathbbC^n, where mathbbH =  c_i in mathbbC  c_i = overlinec_n-i  (see the mathematical prerequisites sections for a proof). As such, as long as the value we try to encod is in mathbbH our coefficients will be real and we can use our primitive to compute them.","category":"page"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"So let's try that:","category":"page"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"using FFTW\n\nœà(a) = a .* [Complex{Float64}(exp(big(-2*k/(2*length(a))*pi*im))) for k in eachindex(a)]\nœà‚Åª¬π(a) = a .* [Complex{Float64}(exp(big(2*k/(2*length(a))*pi*im))) for k in eachindex(a)]\n\nplain1 = LinRange(0.0, 2.0, 2048)\nplain2 = [2.0 for i=0:2047]\n\n# Make it an element of ‚Ñç\nplain1 = [plain1; map(conj, reverse(plain1))]\nplain2 = [plain2; map(conj, reverse(plain2))]\n\nto_fixed(x) = reinterpret.(Int128, Fixed{Int128, 35}.(x))\na = zero(plaintext_space(ckksp))\nb = zero(plaintext_space(ckksp))\na .= to_fixed(real.(œà‚Åª¬π(OffsetArray(ifft(collect(plain1)), 0:4095))))\nb .= to_fixed(real.(œà‚Åª¬π(OffsetArray(ifft(collect(plain2)), 0:4095))))\n\nc1, c2 = encrypt.(kp, (a, b))\ny = c1*c2\ndec_raw = Float64.(reinterpret.(Fixed{Int128, 70}, convert.(Integer, ToyFHE.SignedMod.(ToyFHE.NTT.coeffs_primal(decrypt(kp, y))))))\nfft(collect(œà(dec_raw)))[1:2048]\n\n# output\n2048-element Array{Complex{Float64},1}:\n -1.5783516373879536e-6 + 8.360154309303663e-7im\n   0.001953265729577769 - 6.287625729356563e-7im\n     0.0039068079904514 - 2.7258837087105554e-6im\n   0.005860982470267118 + 1.540880824177161e-7im\n                        ‚ãÆ","category":"page"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"which compares quite favourably to the true answer:","category":"page"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"julia> LinRange(0.0, 2.0, 2048) * 2.0\n2048-element LinRange{Float64}:\n 0.0,0.00195408,0.00390816,0.00586224,0.00781632,0.00977040,0.0117245,0.0136786,0.0156326,‚Ä¶,3.98046,3.98241,3.98437,3.98632,3.98828,3.99023,3.99218,3.99414,3.99609,3.99805,4.0","category":"page"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"(to a precision of about 10^-6).","category":"page"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"Of course, this is all a bit complicated, so the library provides utilities that do all of this encoding and decoding for you:","category":"page"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"scale = 2^35\nTscale = FixedRational{scale}\nTscalesq = FixedRational{Int128(scale)^2}\n\nplain1 = CKKSEncoding{Tscale}(zero(plaintext_space(ckksp)))\nplain1 .= OffsetArray(LinRange(0.0, 2.0, 2048), 0:2047)\n\nplain2 = CKKSEncoding{Tscale}(zero(plaintext_space(ckksp)))\nplain2 .= 2.0\n\nc1, c2 = encrypt.(kp, (plain1, plain2))\ny = c1*c2\nCKKSEncoding{Tscalesq}(decrypt(kp, y))","category":"page"},{"location":"man/ckks/#Rescaling-by-modswitch-1","page":"The CKKS encryption scheme","title":"Rescaling by modswitch","text":"","category":"section"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"TODO","category":"page"},{"location":"man/ckks/#Summary-1","page":"The CKKS encryption scheme","title":"Summary","text":"","category":"section"},{"location":"man/ckks/#","page":"The CKKS encryption scheme","title":"The CKKS encryption scheme","text":"So that's it. It is often stated the the plaintext space of CKKS is mathbbC^n2, which is not wrong of course, but by itself also doesn't grant much insight. Having gone through this construction, we see that arriving at the CKKS construction is quite natural when one sits down and attempts to do arithmetic on encrypted reals. Let us Nevertheless recall the two core ideas:     - Using the otherwise unused noise bits in exchange for a noisy output (but       recovering lots of intermediate precision).     - Doing the FFT in the complex domain instead of the finite field to get       improved noise properties.","category":"page"},{"location":"man/background/fhe/#Cryptographic-Schemes-for-FHE-1","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"","category":"section"},{"location":"man/background/fhe/#FHE-generally-1","page":"Cryptographic Schemes for FHE","title":"FHE generally","text":"","category":"section"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"A general (public-key) FHE scheme provides the following functions:","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"(pub, priv) = keygen(...) - Generates public and private keys\ncipher = encrypt(pub, plain) - Encrypts x using the public key pub\nplain = decrypt(priv, cipher) - Decrypts the ciphertext using private key priv\ncipher_new = eval(f, ciphers...) - Compute the function f on the encrypted values","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"One particular important distinction between different FHE schemes is what functions f are allowed to be homomorphically. In particular, in order to be considered a somewhat or fully homomorphic encryption scheme (abbreviated SHE and FHE respectively), f needs to range over at least two different values that together allow some sort of universality (e.g. + and * on booleans is sufficient). The difference between SHE and FHE schemes is that SHE schemes may have a limit on the number of times that eval may be called, while FHE schemes are defined not to have such a limit. It is possible to turn many SHE schemes into FHE schemes using bootstrapping","category":"page"},{"location":"man/background/fhe/#FHE-using-RLWE-1","page":"Cryptographic Schemes for FHE","title":"FHE using RLWE","text":"","category":"section"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"Since we are in the RLWE setting, the basic primitives we have available are polynomial multiplication (mod q and some cyclotomic) and polynomial addition or equivalently negacyclic convolution and addition for length n arrays. All three supported schemes BGV, BFV and CKKS allow evaluating negacyclic convolution and addition on encrypted length n arrays, though they differ in precisely how they embed their plaintext space into each polynomial. Broadly speaking BGV encodes the plaintext into the (masked) lower bits of the ciphertext, BFV encodes bits into the upper bits of the ciphertext and CKKS is, well complicated, but somewhat similar to BFV. Nevertheless, they do share a lot in common, so let's go over those parts and then revisit.","category":"page"},{"location":"man/background/fhe/#Key-generation-for-RLWE-FHE-schemes-1","page":"Cryptographic Schemes for FHE","title":"Key generation for RLWE FHE schemes","text":"","category":"section"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"The key structure is the same among all three schemes:","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"const ‚ÑõE = RingElement{‚Ñõ}\n\nstruct PrivKey\n    s::‚ÑõE\nend\n\nstruct PubKey\n    mask::‚ÑõE\n    masked::‚ÑõE\nend","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"We now define three probability distributions mathscrU the uniform distribution over mathscrRE, mathscrG whose probability has discrete support near 0 and \"small\" standard deviation (common choices are discrete gaussian distributions with standard deviation frac8sqrt2pi$ or the uniform distribution on -1 0 1), as well as a noise distribution mathscrN that is scheme specific and may or may not be the same as mathscrG.","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"We then compute","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"s = rand(ùí¢)\nmask = rand(ùí∞)\nmasked = -(mask * s + rand(ùí©))","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"Note that that the problem of computing the private key s from the public key (mask, masked) is precisely the ring learning with error problem (i.e. the added noise makes computing s from masked hard, even if we do know the mask).","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"note: Note\nWe use the opposite sign for masked from what is found in the literature on the BGV scheme. The reason for this deviation is to unify the presentation for all three schemes (The papers on BFV and CKKS generally follow the same sign convention as were are using here).","category":"page"},{"location":"man/background/fhe/#Encryption-in-RLWE-FHE-1","page":"Cryptographic Schemes for FHE","title":"Encryption in RLWE FHE","text":"","category":"section"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"A fresh cipher text consits of two ring elements c‚ÇÄ and c‚ÇÅ computed as follows:","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"u = rand(ùí¢)\nc‚ÇÄ = u * masked + rand(ùí©) + œÄ‚Åª¬π(plain)\nc‚ÇÅ = u * mask + rand(ùí©)","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"where Œ≥ is a scheme specific embedding function that maps the plaintext space into the cipher text space.","category":"page"},{"location":"man/background/fhe/#Homomorphic-addition-1","page":"Cryptographic Schemes for FHE","title":"Homomorphic addition","text":"","category":"section"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"Homomorphic addition is simple. For two ciphertext (c‚ÇÄ¬π, c‚ÇÅ¬π) and (c‚ÇÄ¬≤, c‚ÇÅ¬≤), we simply add the ciphertexts elementwise and compute:","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"c‚ÇÄ‚Ä≤ = c‚ÇÄ¬π + c‚ÇÄ¬≤\nc‚ÇÅ‚Ä≤ = c‚ÇÅ¬π + c‚ÇÅ¬≤","category":"page"},{"location":"man/background/fhe/#Homomorphic-multiplication-1","page":"Cryptographic Schemes for FHE","title":"Homomorphic multiplication","text":"","category":"section"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"Homomorphic multiplication is generally similar between the schemes but differs in the details. This presentation most closely matches BGV. For two ciphertext (c‚ÇÄ, c‚ÇÅ) and (d‚ÇÄ, d‚ÇÅ), we compute","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"c‚ÇÄ‚Ä≤ = c‚ÇÄ * d‚ÇÄ\nc‚ÇÅ‚Ä≤ = c‚ÇÄ * d‚ÇÅ + d‚ÇÄ + c‚ÇÅ\nc‚ÇÇ‚Ä≤ = c‚ÇÅ * d‚ÇÅ","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"Note that the number of elements in the ciphertext increases. As a result, we generally need to perform relinerization which is described below to get the number of elements of the ciphertext back down to 2. However, it is possible to decrypt ciphertexts with arbitrarily many elements. In general the number of elements in the ciphertexts is the sum of the number of elements in the input ciphertexts minus 1. Whether or not to do relinerization depends on the tradeoff between the cost of relinerization and the cost of performing multiplications with large numbers of ciphertext elements. The general formula for multiplying two ciphertexts is:","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"c_kprime = sum_i+j == k c_i * d_k","category":"page"},{"location":"man/background/fhe/#Decryption-1","page":"Cryptographic Schemes for FHE","title":"Decryption","text":"","category":"section"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"For a ciphertext c = (c‚ÇÄ, ..., c‚±º) the decryption formula is:","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"plain = œÄ(sum(c·µ¢ * s^i for (i,c·µ¢) in enumerate(c)))","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"where œÄ is once again the scheme specific embedding we are familiar with from the encryption step. Why does this work? Well, lets take it one step at a time. Suppose we have a fresh encryption (c‚ÇÄ, c‚ÇÅ). Then we have:","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"c‚ÇÄ = u * masked + rand(ùí©) + œÄ‚Åª¬π(plain) = - u * mask * s - s * rand(ùí©) + œÄ‚Åª¬π(plain)\ns * c‚ÇÅ = u * mask * s + s * rand(ùí©)","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"and thus","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"c‚ÇÄ + c‚ÇÅ = - s * rand(ùí©) + s * rand(ùí©) + œÄ‚Åª¬π(plain)","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"We note that the two noise terms do not cancel, because they are independent draws (they do however cancel in expectation of course). Nevertheless, it is evident that one could choose œÄ and ùí© appropriately such that œÄ projects out the noise terms (recall that s was chosen to have small coefficients). In particular note that we have no term proportional to mask, which was sampled from the uniform distribution.","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"Repeating this exercise for the ciphertext after multiplication we obtain:","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"c‚ÇÄ‚Ä≤ = (u * masked + e‚ÇÅ + œÄ‚Åª¬π(m‚ÇÅ)) * (v * masked + e‚ÇÇ + œÄ‚Åª¬π(m‚ÇÇ))\n    = u * v * masked ^ 2 +\n      masked * (u * e‚ÇÇ + v * e‚ÇÅ + u * œÄ‚Åª¬π(m‚ÇÇ) + v * œÄ‚Åª¬π(m‚ÇÅ)) +\n      e‚ÇÅ * e‚ÇÇ +\n      œÄ‚Åª¬π(m‚ÇÇ)œÄ‚Åª¬π(m‚ÇÇ)\n    =  u * v * mask^2 * s^2 + u * v * e^2\n     - mask * s * (u * e‚ÇÇ + v * e‚ÇÅ + u * œÄ‚Åª¬π(m‚ÇÇ) + v * œÄ‚Åª¬π(m‚ÇÅ))\n     + e * (u * e‚ÇÇ + v * e‚ÇÅ + u * œÄ‚Åª¬π(m‚ÇÇ) + v * œÄ‚Åª¬π(m‚ÇÅ))\n     + e‚ÇÅ * e‚ÇÇ\n     + œÄ‚Åª¬π(m‚ÇÇ)œÄ‚Åª¬π(m‚ÇÇ)\ns * c‚ÇÅ‚Ä≤ = s * (u * masked + e‚ÇÅ + œÄ‚Åª¬π(m‚ÇÅ)) * v * mask +\n          s * (u * masked + e‚ÇÅ + œÄ‚Åª¬π(m‚ÇÅ)) * f‚ÇÇ +\n          s * (v * masked + e‚ÇÇ + œÄ‚Åª¬π(m‚ÇÇ)) * u * mask +\n          s * (v * masked + e‚ÇÇ + œÄ‚Åª¬π(m‚ÇÇ)) * f‚ÇÅ\n        = 2 s * u * v * masked * mask\n        + mask * s * (u * e‚ÇÇ + v * e‚ÇÅ + u * œÄ‚Åª¬π(m‚ÇÇ) + v * œÄ‚Åª¬π(m‚ÇÅ))\n        + s * (u * masked + e‚ÇÅ + œÄ‚Åª¬π(m‚ÇÅ)) * f‚ÇÇ\n        + s * (v * masked + e‚ÇÇ + œÄ‚Åª¬π(m‚ÇÇ)) * f‚ÇÅ\n        = - 2 * u * v * s^2 * mask^2\n          + mask * s * (u * e‚ÇÇ + v * e‚ÇÅ + u * œÄ‚Åª¬π(m‚ÇÇ) + v * œÄ‚Åª¬π(m‚ÇÅ))\n          - s^2 * u * mask * f‚ÇÇ\n          - s^2 * u * mask * f‚ÇÅ\n          + s * (u * e + e‚ÇÅ + œÄ‚Åª¬π(m‚ÇÅ)) * f‚ÇÇ\n          + s * (v * e + e‚ÇÇ + œÄ‚Åª¬π(m‚ÇÇ)) * f‚ÇÅ\n          + 2 * u * v * s * e\ns^2 * c‚ÇÇ‚Ä≤ = (u * mask + f‚ÇÅ) * (v * mask + f‚ÇÇ)\n          = u * mask * mask^2 * s^2 +\n            s^2 * u * mask * f‚ÇÇ +\n            s^2 * v * mask * f‚ÇÅ +\n            s^2 * f‚ÇÅ * f‚ÇÇ","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"Summing these up, we get:","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"c‚ÇÄ‚Ä≤ + s * c‚ÇÅ‚Ä≤ + s^2 * c‚ÇÇ‚Ä≤ =\n    œÄ‚Åª¬π(m‚ÇÅ)œÄ‚Åª¬π(m‚ÇÇ) +\n    + e * (u * e‚ÇÇ + v * e‚ÇÅ + u * œÄ‚Åª¬π(m‚ÇÇ) + v * œÄ‚Åª¬π(m‚ÇÅ))\n    + e‚ÇÅ * e‚ÇÇ\n    + s * (u * e + e‚ÇÅ + œÄ‚Åª¬π(m‚ÇÅ)) * f‚ÇÇ\n    + s * (v * e + e‚ÇÇ + œÄ‚Åª¬π(m‚ÇÇ)) * f‚ÇÅ\n    + 2 * u * v * s * e\n    + s^2 * f‚ÇÅ * f‚ÇÇ","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"where e‚ÇÅ, e‚ÇÇ, e, f‚ÇÅ, f‚ÇÇ are the various values samples from ùí©. Clearly this decryption is more complicated. All the various noise terms are \"small\", but we're multiplying a lot of them (and some by the embedded message), so the noise is certainly significant. However, the important thing to notice is that we have canceled all terms proportional to mask.","category":"page"},{"location":"man/background/fhe/#Keyswitching-/-Modulus-Switching-1","page":"Cryptographic Schemes for FHE","title":"Keyswitching / Modulus Switching","text":"","category":"section"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"TODO","category":"page"},{"location":"man/background/fhe/#BGV-1","page":"Cryptographic Schemes for FHE","title":"BGV","text":"","category":"section"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"We now turn to the three schemes themselves in order to specify the various operations we had left open above. For, BGV, we have:","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"ùí© = p * ùí¢\nœÄ‚Åª¬π(plain) = plain\nœÄ(c) = mod(c, p)","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"It is easy to see that this works. In our expression above, ever value sampled from ùí© is proportional to p and thus our decryption will be equal to m‚ÇÅ * m‚ÇÇ + p * noise equiv m‚ÇÅ * m‚ÇÇ (mod p) (as long as the total magnitude of p*noise is less than the ciphertext modulus q). We have thus constructed a scheme that can homomorphically evaluate operations in ‚Ñ§/p‚Ñ§. Recall from the introduction that we said BGV embeds the plaintext in the \"low order bits\" of the ciphertext. Perhaps a more precise statement would be that in BGV the plaintext is the (masked) last digit of the ciphertext in base p.","category":"page"},{"location":"man/background/fhe/#BFV-1","page":"Cryptographic Schemes for FHE","title":"BFV","text":"","category":"section"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"BFV is essentially the opposite of BGV. We set:","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"ùí© = ùí¢\nœÄ‚Åª¬π(plain) = q/p * plain\nœÄ(c) = div(c, q/p, RoundToNearest)","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"Because of this encoding we make one additional modification to the scheme. After every multiplication we divide by Œî = q/p (multiply by p/q) to rescale the plaintext to be once again be proportional to Œî. In order to do this, we amend the multiplication procedure as follows: Before performing the multiplication, we switch the coefficients to some larger modulus q*t where t is of same magnitude as (in number of bits) but slightly larger q than q. As a result, we know that (Œî * m‚ÇÅ) * (Œî * m‚ÇÇ) < Œî^2 m‚ÇÅ m‚ÇÇ < q^2 < q * t and thus no modular wraparound occurs (which would lose the top bits of our plaintext).","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"Of course we could instead go all the way to ‚Ñ§. However, using q*s lets us continue using the fast NTT-based arithmetic to the multiplication.","category":"page"},{"location":"man/background/fhe/#CKKS-1","page":"Cryptographic Schemes for FHE","title":"CKKS","text":"","category":"section"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"CKKS is special among the three schemes we support in that it is not exact, i.e. we only ensure that the decrypted value approximately correct (for values of approximately that depend on the parameters of the scheme). As such, we use the perhaps paradoxically simple setup:","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"ùí© = ùí¢\nœÄ‚Åª¬π(plain) = plain\nœÄ(c) = c","category":"page"},{"location":"man/background/fhe/#","page":"Cryptographic Schemes for FHE","title":"Cryptographic Schemes for FHE","text":"We thus see that even for fresh encryptions, the low order digits lose precision. Note that we do often still perform a BFV-like rescaling operation during multiplication in CKKS as we tend to think of the plaintext as some fixed point integer. Because the details are tricky and require additional functionality we have not yet discussed, working with CKKS will be explained in its own manual section later.","category":"page"},{"location":"man/prerequisites/#Mathematical-prerequisites-1","page":"Mathematical prerequisites","title":"Mathematical prerequisites","text":"","category":"section"},{"location":"man/prerequisites/#","page":"Mathematical prerequisites","title":"Mathematical prerequisites","text":"** This page needs to be written. The below is an outline **","category":"page"},{"location":"man/prerequisites/#","page":"Mathematical prerequisites","title":"Mathematical prerequisites","text":"This manual page is to be written. The intent here is to give a quick mathematical overview of all the required mathematical concepts needed to understand the rest of the manual. However, it is not intended as a complete reference and should contain links to more in-depth material where applicable. Where possible this guide should make concrete references to how theses concepts are represented in code in this package.","category":"page"},{"location":"man/prerequisites/#Modular-Arithmetic-1","page":"Mathematical prerequisites","title":"Modular Arithmetic","text":"","category":"section"},{"location":"man/prerequisites/#","page":"Mathematical prerequisites","title":"Mathematical prerequisites","text":"Provided by either the GaloisFields.jl package or Nemo.jl","category":"page"},{"location":"man/prerequisites/#Chinese-remainder-theorem-1","page":"Mathematical prerequisites","title":"Chinese remainder theorem","text":"","category":"section"},{"location":"man/prerequisites/#The-Number-Theoretic-Transform-Fourier-Transforms-over-finite-fields-1","page":"Mathematical prerequisites","title":"The Number Theoretic Transform - Fourier Transforms over finite fields","text":"","category":"section"},{"location":"man/prerequisites/#Correspondence-between-NTT-and-the-roots-of-a-cyclotomic-polynomial-1","page":"Mathematical prerequisites","title":"Correspondence between NTT and the roots of a cyclotomic polynomial","text":"","category":"section"},{"location":"man/prerequisites/#Hensel-lifting-1","page":"Mathematical prerequisites","title":"Hensel lifting","text":"","category":"section"},{"location":"man/prerequisites/#Discrete-Gaussians-1","page":"Mathematical prerequisites","title":"Discrete Gaussians","text":"","category":"section"},{"location":"#ToyFHE.jl-1","page":"ToyFHE.jl","title":"ToyFHE.jl","text":"","category":"section"},{"location":"#","page":"ToyFHE.jl","title":"ToyFHE.jl","text":"A pure-julia implementation of homomorphic encryption.","category":"page"},{"location":"#Overview-1","page":"ToyFHE.jl","title":"Overview","text":"","category":"section"},{"location":"#","page":"ToyFHE.jl","title":"ToyFHE.jl","text":"This package provides clean implementations of a variety of homomorphic encryption protocols. Special attention is paid to clarity of presentation. In particular, a goal of this package is that the implementations can be used as references for the particular cryptographic protocol in question. This gives rise to a couple of design decisions:","category":"page"},{"location":"#","page":"ToyFHE.jl","title":"ToyFHE.jl","text":"1. Where possible code is shared between the various encryption protocols.\n   Multiple dispatch makes it relatively easy to select an appropriate\n   implementation for each protocol where they differ. However, as much\n   as possible common code should be preferred to highlight similarities\n   between the protocols.\n\n2. Performance optimizations are hidden behind type abstractions. As much\n   as possible the main implementations for each protocol should match the\n   textbook pseudocode for each scheme. Where optimizations are done for\n   performance, these should be separated out into methods on a particular\n   implementation type corresponding to that optimizations (or set of\n   optimizations).\n\n3. The code should be kept small and modular.\n\n4. After reading the manual you should feel that you'd be able to completely\n   reimplement this package from scratch if you wanted to.","category":"page"},{"location":"#","page":"ToyFHE.jl","title":"ToyFHE.jl","text":"In addition to modular arithmetic, the primary computational primitive needed by the schemes implemented in this package is polynomial multiplication modulo a certain cyclotomic polynomial. Two backends are available that provide this primitive:","category":"page"},{"location":"#","page":"ToyFHE.jl","title":"ToyFHE.jl","text":"A native julia one implemented in this package, based on (FourierTransforms.jl)[https://github.com/JuliaComputing/FourierTransforms.jl].\nlibflint, via the (Nemo.jl)[https://github.com/Nemocas/Nemo.jl] stack of packages.","category":"page"},{"location":"#","page":"ToyFHE.jl","title":"ToyFHE.jl","text":"The former is written in pure julia all the way down and expected to be more performant and more easily portable to new hardware architectures, but is restricted to power of two cyclotomics, while the latter is ultimately implemented in C, but has support for arbitrary cyclotomics. The implications of this will be discussed later and functionality that requires arbitrary cyclotomics should be appropriatly marked in the documentation.","category":"page"},{"location":"#Usage-1","page":"ToyFHE.jl","title":"Usage","text":"","category":"section"},{"location":"#","page":"ToyFHE.jl","title":"ToyFHE.jl","text":"Users simply wishing to try out the package are encouraged to check the Quickstart Guide or the Examples. However, those intending to seriously use or extend the package are encouraged to read the full manual:","category":"page"},{"location":"#","page":"ToyFHE.jl","title":"ToyFHE.jl","text":"Pages = [\n    \"man/prerequisites.md\",\n    \"man/background.md\",\n    \"man/encoding.md\",\n    \"man/ckks.md\"\n]\nDepth = 2","category":"page"}]
}
